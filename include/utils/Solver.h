//
// Created by fogoz on 12/05/2025.
//
/**
 *Generated using IA please take them with a grain of salt, some human modifications were made but it's partially generated by ia
 */
#ifndef SOLVER_H
#define SOLVER_H
#include <cmath>
#include <array>
#ifndef ARDUINO
#include <iterator>
#endif
// --- Generic 2x2 Matrix Solver (Ax = b) ---
constexpr std::optional<std::array<double, 2>> solve2x2(const std::array<std::array<double, 2>, 2>& A, const std::array<double, 2>& b) {
    double det = A[0][0] * A[1][1] - A[0][1] * A[1][0];
    if (fabs(det) < 1e-10) return std::nullopt; // Singular matrix

    double x = (b[0] * A[1][1] - b[1] * A[0][1]) / det;
    double y = (A[0][0] * b[1] - A[1][0] * b[0]) / det;
    return std::array<double, 2>({x, y});
}
constexpr std::optional<std::array<double, 3>> solve3x3(const std::array<std::array<double, 3>,3>& A, std::array<double, 3> b) {
    // LU decomposition (Crout's method)
    double LU[3][3];
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            LU[i][j] = A[i][j];
        }
    }

    // Partial pivoting (optional but improves stability)
    for (int k = 0; k < 3; ++k) {
        // Find pivot row
        int max_row = k;
        for (int i = k + 1; i < 3; ++i) {
            if (fabs(LU[i][k]) > fabs(LU[max_row][k])) {
                max_row = i;
            }
        }

        // Swap rows if needed
        if (max_row != k) {
            for (int j = 0; j < 3; ++j) {
                double tmp = LU[k][j];
                LU[k][j] = LU[max_row][j];
                LU[max_row][j] = tmp;
            }
            double tmp = b[k];
            b[k] = b[max_row];
            b[max_row] = tmp;
        }

        // Singular matrix?
        if (fabs(LU[k][k]) < 1e-10) {
            return std::nullopt;
        }

        // Eliminate below
        for (int i = k + 1; i < 3; ++i) {
            double factor = LU[i][k] / LU[k][k];
            for (int j = k + 1; j < 3; ++j) {
                LU[i][j] -= factor * LU[k][j];
            }
            b[i] -= factor * b[k];
        }
    }
    std::array<double, 3> x{};
    // Back substitution
    x[2] = b[2] / LU[2][2];
    x[1] = (b[1] - LU[1][2] * x[2]) / LU[1][1];
    x[0] = (b[0] - LU[0][1] * x[1] - LU[0][2] * x[2]) / LU[0][0];
    return x;
}
#ifndef ARDUINO
template <class T, std::size_t N>
std::ostream& operator<<(std::ostream& os, const std::array<T, N>& arr)
{
    os << "[";
    for (std::size_t i = 0; i < N; ++i) {
        os << arr[i];
        if (i != N - 1)
            os << ", ";
    }
    os << "]";
    return os;
}
#endif


#endif //SOLVER_H
